
* Basic Interface Settings
These are setting that do not depend on packages and are built-in enhancements to the UI.

** Check Mac or Windows
#+BEGIN_SRC emacs-lisp
(defconst *is-a-mac* (eq system-type 'darwin))
(defconst *is-a-win* (eq system-type 'windows-nt))
#+END_SRC

** Looks
*** Remove lame startup screen
We use an actual replacement for it, keep reading or head directly to =dashboard=.
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message nil)
#+END_SRC

*** Disable menus and scrollbars
If you like using any of those, change =-1= to =1=.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
;;(menu-bar-mode 1)
;;(scroll-bar-mode 1)
#+END_SRC

*** Disable bell
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

*** Set UTF-8 encoding
#+BEGIN_SRC emacs-lisp 
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC

*** Highligh current line
=hl-line= is awesome! It's not very awesome in the terminal version of emacs though, so we don't use that.
#+BEGIN_SRC emacs-lisp
(when window-system (global-hl-line-mode t))
#+END_SRC

*** Pretty symbols
Changes =lambda= to an actual symbol and a few others as well, only in the GUI version though.
#+BEGIN_SRC emacs-lisp
;; (when window-system (global-prettify-symbols-mode t))
#+END_SRC

*** Front Size

#+BEGIN_SRC emacs-lisp
;; Set front size, the value is in 1/10pt, so 160=16pt
(when *is-a-mac*
  (set-face-attribute 'default nil :height 160))

(when *is-a-win*
  (set-face-attribute 'default nil :height 120)
  (add-hook 'emacs-startup-hook 'toggle-frame-maximized)
  )
#+END_SRC

*** Stretch cursor
Make Cursor the width of the character it is nder full width of a TAB
#+BEGIN_SRC emacs-lisp
(setq x-stretch-cursor t)
#+END_SRC

*** Add spacing between english and chinese word
#+BEGIN_SRC emacs-lisp
  (use-package pangu-spacing
    :ensure t
    :init
    (global-pangu-spacing-mode 1))
#+END_SRC

*** Show line number in left
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'linum-mode)
#+END_SRC

** Functionality

*** Disable backups and auto-saves
I don't use either, you might want to turn those from =nil= to =t= if you do.
#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
(setq auto-save-default nil)
#+END_SRC

*** Change yes-or-no questions into y-or-n questions
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Emacs Server
#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC
** User Info

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Marco Chiu")
(setq user-mail-address "chiumarco@gmail.com")
#+END_SRC


* Themes

** Leuven
Default theme.
#+BEGIN_SRC emacs-lisp
(load-theme 'leuven t)
#+END_SRC

** Function to toggle between light and dark

#+BEGIN_SRC emacs-lisp
;; Ensure that themes will be applied even if they have not been customized
(defun reapply-themes ()
  "Forcibly load the themes listed in `custom-enabled-themes'."
  (dolist (theme custom-enabled-themes)
    (unless (custom-theme-p theme)
      (load-theme theme)))
  (custom-set-variables `(custom-enabled-themes (quote ,custom-enabled-themes))))

(add-hook 'after-init-hook 'reapply-themes)

(defun light ()
  "Activate a light color theme."
  (interactive)
  (load-theme 'leuven t)
  (reapply-themes)
  )

(defun dark ()
  "Activate a dark color theme."
  (interactive)
  (load-theme 'leuven-dark t)
  (reapply-themes)
  )
#+END_SRC


* Modeline
** Spaceline
Powerline theme from Spacemacs
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :config
    (require 'spaceline-config)
      (setq spaceline-buffer-encoding-abbrev-p nil)
      (setq spaceline-line-column-p nil)
      (setq spaceline-line-p nil)
      (setq powerline-default-separator (quote arrow))
      (spaceline-spacemacs-theme))
#+END_SRC

** Cursor position
Show the current line and column for your cursor.
#+BEGIN_SRC emacs-lisp
  (line-number-mode t)
  (column-number-mode t)
#+END_SRC

** Clock
If you prefer the 12hr-format, change the variable to =nil= instead of =t=.

*** Time format
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
  (setq display-time-format "%H:%M - %d %B %Y")
#+END_SRC

*** Enabling the mode
This turns on the clock globally.
#+BEGIN_SRC emacs-lisp
  (display-time-mode 1)
#+END_SRC

** Diminishing modes
The package =diminish= disables modes on the mode line but keeps
them running, it just prevents them from showing up and taking up space.

#+BEGIN_SRC emacs-lisp
    (use-package diminish
      :ensure t
      :init
      (diminish 'which-key-mode)
      ;(diminish 'linum-relative-mode)
      )
#+END_SRC


* Projectile
Projectile is an awesome project manager, mostly because it recognizes directories
with a =.git= directory as projects and helps you manage them accordingly.

** Enable projectile globally
This makes sure that everything can be a project.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init
      (projectile-mode 1))
#+END_SRC


* Dashboard
This is your new startup screen, together with projectile it works in unison and
provides you with a quick look into your latest projects and files.
Change the welcome message to whatever string you want and
change the numbers to suit your liking, I find 5 to be enough.

#+BEGIN_SRC emacs-lisp
  ;; (use-package dashboard
  ;;   :ensure t
  ;;   :config
  ;;     (dashboard-setup-startup-hook)
  ;;     (setq dashboard-banner-logo-title "Welcome to Emacs!")
  ;;     (setq dashboard-startup-banner 'official)
  ;;     (setq dashboard-items '((recents  . 5)
  ;;                             (projects . 5)
  ;;                             (bookmark . 5)
  ;;                             (agenda   . 5)))
  ;;     (add-to-list 'dashboard-items '(agenda) t))
#+END_SRC


* File manager

** Treemacs - a tree layout file explorer for Emacs
To show icon in treemacs in Windows, need install dependencies as well (=emacs-25-x86_64-deps.zip=).
#+BEGIN_SRC emacs-lisp
      (use-package treemacs
        :ensure t
        :defer t
        :config
        (progn
          (setq treemacs-follow-after-init t
                treemacs-width 35
                treemacs-indentation 2
                treemacs-collapse-dirs (if (executable-find "python") 3 0)
                treemacs-silent-refresh nil
                treemacs-change-root-without-asking nil
                treemacs-sorting 'alphabetic-desc
                treemacs-show-hidden-files t
                treemacs-never-persist nil
                treemacs-is-never-other-window nil
                treemacs-goto-tag-strategy 'refetch-index)

          (treemacs-follow-mode t)
          (treemacs-filewatch-mode t)
          (pcase (cons (not (null (executable-find "git")))
                       (not (null (executable-find "python3"))))
            (`(t . t)
             (treemacs-git-mode 'extended))
            (`(t . _)
             (treemacs-git-mode 'simple))))
        :bind
        (:map global-map
              ([f8] . treemacs-toggle)))

      (use-package treemacs-projectile
        :defer t
        :ensure t
        :config
            (setq treemacs-header-function #'treemacs-projectile-create-header)
        :bind (:map global-map
                    ([f9] . treemacs-projectile)
                    ([f9] . treemacs-projectile-toggle)))
#+END_SRC


* Moving around emacs

** Ivy
Ivy, a generic completion mechanism for Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t)
#+END_SRC

** Counsel
Counsel, a collection of Ivy-enhanced versions of common Emacs commands.

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  )
#+END_SRC

** Swiper
Swiper, an Ivy-enhanced alternative to isearch.

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
  :config
  (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (global-set-key "\C-s" 'swiper)
    (global-set-key (kbd "C-c C-r") 'ivy-resume)
    (global-set-key (kbd "<f6>") 'ivy-resume)
    (global-set-key (kbd "M-x") 'counsel-M-x)
    (global-set-key (kbd "C-x C-f") 'counsel-find-file)
    (global-set-key (kbd "<f1> f") 'counsel-describe-function)
    (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
    (global-set-key (kbd "<f1> l") 'counsel-load-library)
    (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
    (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
    (global-set-key (kbd "C-c g") 'counsel-git)
    (global-set-key (kbd "C-c j") 'counsel-git-grep)
    (global-set-key (kbd "C-c k") 'counsel-ag)
    (global-set-key (kbd "C-x l") 'counsel-locate)
    (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
    (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
    )
#+END_SRC

** scrolling and why does the screen move
I don't know to be honest, but this little bit of code makes scrolling with emacs a lot nicer.
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

** which-key
Emacs package that displays available keybindings in popup.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config
      (which-key-mode))
#+END_SRC

** For windows operation
*** Winner Mode
Winner Mode is a global minor mode. When activated, it allows you to =undo= (and =redo=) changes in the window configuration with the key commands =C-c left= and =C-c right=.

#+BEGIN_SRC emacs-lisp
(require 'winner)
(winner-mode 1)
#+END_SRC

*** Following window splits
After you split a window, your focus remains in the previous one.
This annoyed me so much I wrote these two, they take care of it.
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

*** Windows move
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-[") 'windmove-up)
(global-set-key (kbd "M-/") 'windmove-down)
(global-set-key (kbd "M-'") 'windmove-right)
(global-set-key (kbd "M-;") 'windmove-left)
(global-set-key (kbd "M-:") 'comment-line)
#+END_SRC

** Buffers
*** Always murder current buffer
Doing =C-x k= should kill the current buffer at all times.
#+BEGIN_SRC emacs-lisp
  (defun kill-current-buffer ()
    "Kills the current buffer."
    (interactive)
    (kill-buffer (current-buffer)))
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC

*** Kill buffers without asking for confirmation
#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC

*** Turn switch-to-buffer into ibuffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

**** Defining filter groups
#+BEGIN_SRC emacs-lisp
    (setq ibuffer-saved-filter-groups
          '(("home"
            ("emacs-config" (or (filename . ".emacs.d")
                                (filename . "emacs-config")))
             ("Org" (or (mode . org-mode)
                        (filename . "OrgMode")))
             ("code" (filename . "code"))
             ("Web Dev" (or (mode . html-mode)
                            (mode . css-mode)))
             ("Subversion" (name . "\*svn"))
             ("Magit" (name . "\*magit"))
             ("Markdown" (filename . ".md"))
             ("Help" (or (name . "\*Help\*")
                         (name . "\*Apropos\*")
                         (name . "\*info\*"))))))
  (add-hook 'ibuffer-mode-hook
            '(lambda ()
               (ibuffer-auto-mode 1)
               (ibuffer-switch-to-saved-filter-groups "home")))
  (setq ibuffer-show-empty-filter-groups nil)
#+END_SRC

**** expert-mode
If you feel like you know how ibuffer works and need not to be asked for confirmation after every serious command, enable this as follows.
#+BEGIN_SRC emacs-lisp
;; (setq ibuffer-expert t)
#+END_SRC

*** close-all-buffers
It's one of those things where I genuinely have to wonder why there is no built in functionality for it.
Once in a blue moon I need to kill all buffers, and having ~150 of them open would mean I'd need to spend a few too many
seconds doing this than I'd like, here's a solution.

This can be invoked using =C-M-s-k=. This keybinding makes sure you don't hit it unless you really want to.
#+BEGIN_SRC emacs-lisp
  (defun close-all-buffers ()
    "Kill all buffers without regard for their origin."
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
  (global-set-key (kbd "C-M-s-k") 'close-all-buffers)
#+END_SRC



* Minor conveniences

** Beacon
While changing buffers or workspaces, the first thing you do is look for your cursor.
Unless you know its position, you can not move it efficiently. Every time you change
buffers, the current position of your cursor will be briefly highlighted now.
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
      (beacon-mode 1))
#+END_SRC

** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth, useful for any language using them,
especially lisp.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init
      (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** Popup menu
Instead of GUI x-popup-menu, I prefer a small minibuffer, it's easier to select options this way.
#+BEGIN_SRC emacs-lisp
  (use-package ace-popup-menu
    :ensure t
    :init
      (ace-popup-menu-mode 1))
#+END_SRC


* Kill ring

** popup-kill-ring
Out of all the packages I tried out, this one, being the simplest, appealed to me most.
With a simple M-y you can now browse your kill-ring like browsing autocompletion items.
C-n and C-p totally work for this.
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC


* Completion
Be it for code or prose, completion is a must.

** company-mode
After messing around with =auto-completion= for a while I decided to drop it
in favor of =company=, and it turns out to have been a great decision.

*** Global mode
I like having it enabled globally myself, so thats what I do.
I set the delay for company mode to kick in to half a second, I also make sure that
it starts doing its magic after typing in only 2 characters.

I prefer =C-n= and =C-p= to move around the items, so I remap those accordingly.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
      (setq company-dabbrev-downcase 0)
      (setq company-idle-delay 0)
      (setq company-minimum-prefix-length 3)
    :init
      (add-hook 'after-init-hook 'global-company-mode))

  (with-eval-after-load 'company
      (define-key company-active-map (kbd "M-n") nil)
      (define-key company-active-map (kbd "M-p") nil)
      (define-key company-active-map (kbd "C-n") #'company-select-next)
      (define-key company-active-map (kbd "C-p") #'company-select-previous))
#+END_SRC

** electric
If you write any code, you may enjoy this.
Typing the first character in a set of 2, completes the second one after your cursor.
Opening a bracket? It's closed for you already. Quoting something? It's closed for you already.

You can easily add and remove pairs yourself, have a look.
#+BEGIN_SRC emacs-lisp
(setq electric-pair-pairs '(
                           (?\{ . ?\})
                           (?\( . ?\))
                           (?\[ . ?\])
                           ))
#+END_SRC

And now to enable it
#+BEGIN_SRC emacs-lisp
(electric-pair-mode t)
#+END_SRC


* Programming

** ediff
#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(ediff-diff-options "-w")
 '(ediff-split-window-function (quote split-window-horizontally))
 '(ediff-window-setup-function (quote ediff-setup-windows-plain)))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "multimarkdown"))
#+END_SRC

Use vmd to live time preview markdown file.
Need install =Node.js= and =vmd=.
#+BEGIN_SRC 
npm install -g vmd
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "packages/vmd-mode" user-emacs-directory))
  (when *is-a-mac*
    (setenv "PATH" (concat "/usr/local/bin:/usr/bin:" (getenv "PATH")))
    (setq exec-path (append '("/usr/local/bin" "/usr/bin") exec-path)))
  (require 'vmd-mode)
#+END_SRC

** Matlab

#+BEGIN_SRC emacs-lisp
(use-package matlab-mode
  :ensure t)
#+END_SRC


* Git integration

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :config
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50))
#+END_SRC


* Mu4e

#+BEGIN_SRC emacs-lisp
  (when *is-a-mac*
    (require 'epa-file)
    (custom-set-variables '(epg-gpg-program  "/usr/local/bin/gpg"))
    (epa-file-enable)

    (defun offlineimap-get-password (host port)
      (require 'netrc)
      (let* ((netrc (netrc-parse (expand-file-name "~/.authinfo.gpg")))
             (hostentry (netrc-machine netrc host port port)))
        (when hostentry (netrc-get hostentry "password"))))

    (require 'mu4e)                      ; load mu4e
    ;; Use mu4e as default mail agent
    (setq mail-user-agent 'mu4e-user-agent)
    ;; Mail folder set to ~/Maildir
    (setq mu4e-maildir "~/Maildir")         ; NOTE: should not be symbolic link
    ;; Fetch mail by offlineimap
    (setq mu4e-get-mail-command "offlineimap")
    ;; Fetch mail in 300 sec interval
    (setq mu4e-update-interval 300)

    ;; (setq mu4e-hide-index-messages t)

    ;; folder for sent messages
    (setq mu4e-sent-folder   "/Gmail/[Gmail].Sent Mail")
    ;; unfinished messages
    (setq mu4e-drafts-folder "/Gmail/[Gmail].Drafts")
    ;; trashed messages
    (setq mu4e-trash-folder  "/Gmail/[Gmail].Trash")
    ;; saved messages
    ;; (setq mu4e-trash-folder  "/Gmail/Archive")

    ;; the maildirs you use frequently; access them with 'j' ('jump')
    (setq   mu4e-maildir-shortcuts
            '(("/Gmail/INBOX"               . ?i)
              ("/Gmail/[Gamil].Sent Mail"   . ?s)
              ("/Gmail/[Gmail].Trash"       . ?t)))


    ;; the headers to show in the headers list -- a pair of a field
    ;; and its width, with `nil' meaning 'unlimited'
    ;; (better only use that for the last field.
    ;; These are the defaults:
    (setq mu4e-headers-fields
          '( (:date          .  25)    ;; alternatively, use :human-date
             (:flags         .   6)
             (:from          .  22)
             (:subject       .  nil))) ;; alternatively, use :thread-subject

    (require 'mu4e-contrib)
    (setq mu4e-html2text-command 'mu4e-shr2text)
    ;; try to emulate some of the eww key-bindings
    (add-hook 'mu4e-view-mode-hook
              (lambda ()
                (local-set-key (kbd "<tab>") 'shr-next-link)
                (local-set-key (kbd "<backtab>") 'shr-previous-link)))

    ;; Call EWW to display HTML messages
    (defun jcs-view-in-eww (msg)
      (eww-browse-url (concat "file://" (mu4e~write-body-to-html msg))))
    ;; Arrange to view messages in either the default browser or EWW
    (add-to-list 'mu4e-view-actions '("ViewInBrowser" . mu4e-action-view-in-browser) t)
    (add-to-list 'mu4e-view-actions '("Eww view" . jcs-view-in-eww) t)
    
    ;; From Ben Maughan: Get some Org functionality in compose buffer
    (add-hook 'message-mode-hook 'turn-on-orgtbl)
    (add-hook 'message-mode-hook 'turn-on-orgstruct++)

    ;; Set format=flowed
    ;; mu4e sets up visual-line-mode and also fill (M-q) to do the right thing
    ;; each paragraph is a single long line; at sending, emacs will add the
    ;; special line continuation characters.
    (setq mu4e-compose-format-flowed t)

    ;; every new email composition gets its own frame! (window)
    ;;(setq mu4e-compose-in-new-frame t)

    ;; give me ISO(ish) format date-time stamps in the header list
    (setq mu4e-headers-date-format "%Y-%m-%d %H:%M")

    ;; show full addresses in view message (instead of just names)
    ;; toggle per name with M-RET
    (setq mu4e-view-show-addresses t)


    (setq mu4e-view-show-images t)

    ;; SMTP setup
    (setq message-send-mail-function 'smtpmail-send-it
          smtpmail-stream-type 'starttls
          starttls-use-gnutls t)
    ;; Personal info
    (setq user-full-name "Marco Chiu")          ; FIXME: add your info here
    (setq user-mail-address "chiumarco@gmail.com"); FIXME: add your info here
    ;; gmail setup
    (setq smtpmail-smtp-server "smtp.gmail.com")
    (setq smtpmail-smtp-service 587)
    (setq smtpmail-smtp-user "chiumarco@gmail.com") ; FIXME: add your gmail addr here

    (setq mu4e-compose-signature "Sent from my emacs.")

    ;; don't keep message buffers after sent message
    (setq message-kill-buffer-on-exit t)

    (global-set-key (kbd "<f6>") 'mu4e)

    )
#+END_SRC

** mu4e-alert
#+BEGIN_SRC emacs-lisp
  (when *is-a-mac*
    (use-package mu4e-alert
      :ensure t
      :after mu4e
      :init
      (setq mu4e-alert-interesting-mail-query
            (concat
             "flag:unread maildir:/Exchange/INBOX "
             "OR "
             "flag:unread maildir:/Gmail/INBOX"
             ))
      (mu4e-alert-enable-mode-line-display)
      (defun gjstein-refresh-mu4e-alert-mode-line ()
        (interactive)
        (mu4e~proc-kill)
        (mu4e-alert-enable-mode-line-display)
        )
      (run-with-timer 0 60 'gjstein-refresh-mu4e-alert-mode-line)    )
    )
#+END_SRC

* Web
** EWW

#+BEGIN_SRC emacs-lisp
(defun eww-render-current-buffer ()
  "Render HTML in the current buffer with EWW"
  (interactive)
  (beginning-of-buffer)
  (eww-display-html 'utf8 (buffer-name)))
#+END_SRC

* Org

** Common settings

#+BEGIN_SRC emacs-lisp
  ;(setq org-ellipsis " ")
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-export-with-smart-quotes t)
  (setq org-src-window-setup 'current-window)
#+END_SRC

** Line wrapping
#+BEGIN_SRC emacs-lisp
    (add-hook 'org-mode-hook
              '(lambda ()
                 (visual-line-mode 1)))
#+END_SRC

** Keybindings

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
#+END_SRC

** Org Bullets
Makes it all look a bit nicer, I hate looking at asterisks.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
      (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC

** Easy-to-add emacs-lisp template
Hitting tab after an "<el" in an org-mode file will create a template for elisp insertion.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
	       '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC

** Agenda

#+BEGIN_SRC emacs-lisp
  ;; Insert timestamp when TODO state changed into DONE state
  (setq org-log-done 'time)
  ;; Uses only one star and indents text to line with the heading:
  (setq org-startup-indented t)
  ;; Only one occurrence is shown, either today or the nearest into the future
  (setq org-agenda-repeating-timestamp-show-all nil)
  ;; Open agenda in current window
  (setq org-agenda-window-setup (quote current-window))
  ;; Warn me of any deadlines in next 7 days
  (setq org-deadline-warning-days 7)
  ;; Don't show tasks as scheduled if they are already shown as a deadline
  (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
  ;; Don't give awarning colour to tasks with impending deadlines
  ;; if they are scheduled to be done
  (setq org-agenda-skip-deadline-prewarning-if-scheduled (quote pre-scheduled))
  ;; Don't show tasks that are scheduled or have deadlines in the
  ;; Normal todo list
  (setq org-agenda-todo-ignore-deadlines (quote all))
  (setq org-agenda-todo-ignore-scheduled (quote all))

  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(n)"  "|" "DONE(d)")
          (sequence "WAITING(w)" "INACTIVE(i)" "MEETING(m)" "|" "CANCELLED(c)" )))

  (require 'org-mobile)
#+END_SRC

** Org Mode File

#+BEGIN_SRC emacs-lisp
    (when *is-a-mac*
      (setq org-directory "~/Dropbox/Emacs/Org")
      (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg"))

    (when *is-a-win*
      (setq org-directory "C:/Users/Marco.Chiu/Dropbox/Emacs/Org")
      (setq org-mobile-directory "C:/Users/Marco.Chiu/Dropbox/Apps/MobileOrg"))

    (defvar path_inbox (concat org-directory "/inbox.org"))
    (defvar path_home (concat org-directory "/home.org"))
    (defvar path_work (concat org-directory "/work.org"))
    (defvar path_personal (concat org-directory "/personal.org"))

    (setq org-default-notes-file path_inbox)
    (setq org-mobile-inbox-for-pull path_inbox)
    (setq org-mobile-files (list path_home path_work path_personal))
    (setq org-agenda-files (list path_home path_work path_personal))

    (setq org-capture-templates
          '(("t" "Todo-Personal" entry (file+headline path_personal "Personal Tasks:") "* TODO %?\n")
            ("h" "Todo-Home" entry (file+headline path_home "Home Tasks:") "* TODO %?\n")
            ("w" "Todo-Work" entry (file+headline path_work "Work Tasks:") "* TODO %?\n")
            ("j" "Todo" entry (file+headline path_inbox "Tasks" ) "* TODO %?\n")
            ))

    (setq org-refile-targets '((path_home :maxlevel . 1)
                               (path_work :maxlevel . 1)
                               (path_personal :maxlevel . 1)))

  (when *is-a-win*
    (defvar path_sha1sum (concat user-emacs-directory "packages/sha1sum.exe"))
    (setq org-mobile-checksum-binary path_sha1sum))
#+END_SRC


* Useful tools

** ispell
#+BEGIN_SRC emacs-lisp
(defun ispell-word-then-abbrev (p)
  "Call `ispell-word'. Then create an abbrev for the correction made.
With prefix P, create local abbrev. Otherwise it will be global."
  (interactive "P")
  (let ((before (downcase (or (thing-at-point 'word) "")))
        after)
    (call-interactively 'ispell-word)
    (setq after (downcase (or (thing-at-point 'word) "")))
    (unless (string= after before)
      (define-abbrev
        (if p local-abbrev-table global-abbrev-table) before after))
      (message "\"%s\" now expands to \"%s\" %sally."
               before after (if p "loc" "glob"))))

(define-key ctl-x-map (kbd "C-i") 'ispell-word-then-abbrev)

(setq save-abbrevs t)
(setq-default abbrev-mode t)
(setq ispell-program-name "aspell")
#+END_SRC

** Youdao Dictionary

#+BEGIN_SRC emacs-lisp
(use-package youdao-dictionary
  :ensure t
  :bind ("C-c d" . youdao-dictionary-search-at-point)
  :init (setq url-automatic-caching t))
#+END_SRC

** Try
 Try Emacs packages without installing them.

#+BEGIN_SRC emacs-lisp
(use-package try
  :ensure t)
#+END_SRC
** Pandoc-mode
#+BEGIN_SRC emacs-lisp
(use-package pandoc-mode
  :ensure t)
#+END_SRC
